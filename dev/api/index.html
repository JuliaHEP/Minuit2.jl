<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · Minuit2.jl</title><meta name="title" content="Public API · Minuit2.jl"/><meta property="og:title" content="Public API · Minuit2.jl"/><meta property="twitter:title" content="Public API · Minuit2.jl"/><meta name="description" content="Documentation for Minuit2.jl."/><meta property="og:description" content="Documentation for Minuit2.jl."/><meta property="twitter:description" content="Documentation for Minuit2.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Minuit2.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Public API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/introduction/">Introduction to Minuit2.jl</a></li><li><a class="tocitem" href="../tutorials/costfunctions/">Cost Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Advanced</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/combined/">Combined Fits</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">RooFit</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/roofit/">RooFit Modelling</a></li><li><a class="tocitem" href="../tutorials/roofit_basics/">RooFit Basics</a></li></ul></li></ul></li><li><a class="tocitem" href="../release_notes/">Release Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Public API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaHEP/Minuit2.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaHEP/Minuit2.jl/blob/main/docs/src/api.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-Documentation"><a class="docs-heading-anchor" href="#Public-Documentation">Public Documentation</a><a id="Public-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Documentation" title="Permalink"></a></h1><p>Documentation for <code>Minuit2.jl</code> public interface.</p><hr/><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Minuit2.BinnedNLL-Union{Tuple{F}, Tuple{AbstractArray, Union{Tuple, AbstractArray}, F}} where F&lt;:Function"><code>Minuit2.BinnedNLL</code></a></li><li><a href="#Minuit2.Constant-Tuple{Float64}"><code>Minuit2.Constant</code></a></li><li><a href="#Minuit2.CostSum-Tuple{Vararg{CostFunction}}"><code>Minuit2.CostSum</code></a></li><li><a href="#Minuit2.ExtendedBinnedNLL-Union{Tuple{F}, Tuple{AbstractArray, Union{Tuple, AbstractArray}, F}} where F&lt;:Function"><code>Minuit2.ExtendedBinnedNLL</code></a></li><li><a href="#Minuit2.ExtendedUnbinnedNLL-Union{Tuple{F}, Tuple{AbstractArray, F}} where F&lt;:Function"><code>Minuit2.ExtendedUnbinnedNLL</code></a></li><li><a href="#Minuit2.LeastSquares-Tuple{AbstractArray, AbstractVector, Any, Function}"><code>Minuit2.LeastSquares</code></a></li><li><a href="#Minuit2.Minuit-Tuple{Any, Vararg{Any}}"><code>Minuit2.Minuit</code></a></li><li><a href="#Minuit2.Minuit"><code>Minuit2.Minuit</code></a></li><li><a href="#Minuit2.UnbinnedNLL-Union{Tuple{F}, Tuple{AbstractArray, F}} where F&lt;:Function"><code>Minuit2.UnbinnedNLL</code></a></li><li><a href="#Minuit2.RooFit.AbstractPdf"><code>Minuit2.RooFit.AbstractPdf</code></a></li><li><a href="#Minuit2.RooFit.AddPdf-Tuple{Any, Minuit2.RooFit.AbstractPdf, Minuit2.RooFit.AbstractPdf, Minuit2.RooFit.RealVar}"><code>Minuit2.RooFit.AddPdf</code></a></li><li><a href="#Minuit2.RooFit.AddPdf-Tuple{Any, Any, Any}"><code>Minuit2.RooFit.AddPdf</code></a></li><li><a href="#Minuit2.RooFit.ArgusPdf"><code>Minuit2.RooFit.ArgusPdf</code></a></li><li><a href="#Minuit2.RooFit.Chebyshev-Tuple{Any, Any, Any}"><code>Minuit2.RooFit.Chebyshev</code></a></li><li><a href="#Minuit2.RooFit.DataSet"><code>Minuit2.RooFit.DataSet</code></a></li><li><a href="#Minuit2.RooFit.Exponential-Tuple{Any, Any, Any}"><code>Minuit2.RooFit.Exponential</code></a></li><li><a href="#Minuit2.RooFit.FitResult"><code>Minuit2.RooFit.FitResult</code></a></li><li><a href="#Minuit2.RooFit.Gaussian-NTuple{4, Any}"><code>Minuit2.RooFit.Gaussian</code></a></li><li><a href="#Minuit2.RooFit.RealVar"><code>Minuit2.RooFit.RealVar</code></a></li><li><a href="#Minuit2.RooFit.RealVar-Union{Tuple{Any}, Tuple{T}, Tuple{Any, T}, Tuple{Any, T, T}} where T&lt;:Real"><code>Minuit2.RooFit.RealVar</code></a></li></ul><ul><li><a href="#Minuit2.FCN"><code>Minuit2.FCN</code></a></li><li><a href="#Minuit2.FCN"><code>Minuit2.FCN</code></a></li><li><a href="#Minuit2.chi2-Tuple{Any, Any, Any}"><code>Minuit2.chi2</code></a></li><li><a href="#Minuit2.chi2_grad-NTuple{4, Any}"><code>Minuit2.chi2_grad</code></a></li><li><a href="#Minuit2.contour-Tuple{Minuit, Any, Any}"><code>Minuit2.contour</code></a></li><li><a href="#Minuit2.get_nargs-Tuple{Any}"><code>Minuit2.get_nargs</code></a></li><li><a href="#Minuit2.hesse!-Tuple{Minuit}"><code>Minuit2.hesse!</code></a></li><li><a href="#Minuit2.matrix-Tuple{Minuit}"><code>Minuit2.matrix</code></a></li><li><a href="#Minuit2.migrad!"><code>Minuit2.migrad!</code></a></li><li><a href="#Minuit2.minos!-Tuple{Minuit}"><code>Minuit2.minos!</code></a></li><li><a href="#Minuit2.mncontour-Tuple{Minuit, Any, Any}"><code>Minuit2.mncontour</code></a></li><li><a href="#Minuit2.mnprofile-Tuple{Minuit, Any}"><code>Minuit2.mnprofile</code></a></li><li><a href="#Minuit2.multinomial_chi2-Tuple{Any, Any}"><code>Minuit2.multinomial_chi2</code></a></li><li><a href="#Minuit2.multinomial_chi2_grad-Tuple{Any, Any, Any}"><code>Minuit2.multinomial_chi2_grad</code></a></li><li><a href="#Minuit2.poisson_chi2-Tuple{Any, Any}"><code>Minuit2.poisson_chi2</code></a></li><li><a href="#Minuit2.poisson_chi2_grad-Tuple{Any, Any, Any}"><code>Minuit2.poisson_chi2_grad</code></a></li><li><a href="#Minuit2.profile-Tuple{Minuit, Any}"><code>Minuit2.profile</code></a></li><li><a href="#Minuit2.robust_low_level_fit-NTuple{8, Any}"><code>Minuit2.robust_low_level_fit</code></a></li><li><a href="#Minuit2.scan!"><code>Minuit2.scan!</code></a></li><li><a href="#Minuit2.simplex!"><code>Minuit2.simplex!</code></a></li><li><a href="#Minuit2.soft_l1_cost-Tuple{Any, Any, Any}"><code>Minuit2.soft_l1_cost</code></a></li><li><a href="#Minuit2.soft_l1_cost_grad-NTuple{4, Any}"><code>Minuit2.soft_l1_cost_grad</code></a></li><li><a href="#Minuit2.RooFit.ConstVar-Union{Tuple{T}, Tuple{Any, T}} where T&lt;:Real"><code>Minuit2.RooFit.ConstVar</code></a></li><li><a href="#Minuit2.RooFit.fitTo-Tuple{Minuit2.RooFit.AbstractPdf, Any}"><code>Minuit2.RooFit.fitTo</code></a></li><li><a href="#Minuit2.RooFit.generate-Tuple{Minuit2.RooFit.AbstractPdf, Int64}"><code>Minuit2.RooFit.generate</code></a></li></ul><hr/><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><p>This is the list of all types and functions defined for Minuit2</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.BinnedNLL-Union{Tuple{F}, Tuple{AbstractArray, Union{Tuple, AbstractArray}, F}} where F&lt;:Function" href="#Minuit2.BinnedNLL-Union{Tuple{F}, Tuple{AbstractArray, Union{Tuple, AbstractArray}, F}} where F&lt;:Function"><code>Minuit2.BinnedNLL</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BinnedNLL(bincounts::AbstractArray, binedges::Union{AbstractArray, Tuple}, cdf::Function; use_pdf=:none, verbose=0,  grad=nothing, names=())</code></pre><p>Binned negative log-likelihood.</p><p>Use this if only the shape of the fitted PDF is of interest and the data is binned. This cost function works with normal and weighted histograms.  The histogram can be one- or multi-dimensional.</p><p><strong>Arguments</strong></p><ul><li><code>bincounts::AbstractArray</code> : Histogram counts. If this is an array with dimension D, where D is the number of histogram axes.</li><li><code>xe::Union{AbstractArray, Tuple}</code> : Bin edge locations, must be len(n) + 1, where n is the number of bins.  If the histogram has more than one axis, xe must be a collection of the bin edge locations along each axis.</li><li><code>cdf::Function</code> : Cumulative density function of the form f(xe, par0, par1, ..., parN),  where xe is a bin edge and par0, ... are model parameters. The corresponding density must be normalized to unity   over the space covered by the histogram. If the model is multivariate, xe must be an array-like with shape (D, N),  where D is the dimension and N is the number of points where the model is evaluated.</li><li><code>verbose::Int</code> : Verbosity level. 0: is no output.</li><li><code>grad::Union{Function, Nothing} : Optionally pass the gradient of the</code>cdf``. Has the same calling signature like the cdf,   but must return an array with the shape (K,), where K is the number of parameters. The gradient can be used by Minuit to   improve or speed up convergence.</li><li><code>use_pdf::Symbol</code>: Either <code>:none</code>, <code>:numerical</code>, or <code>:approximate</code>. If the model cdf is not available, but the model pdf is,   this option can be set to &quot;numerical&quot; or &quot;approximate&quot; to compute the integral of the pdf over the bin. The option &quot;numerical&quot;   uses numerical integration, which is accurate but computationally expensive and only supported for 1D histograms. The  option &quot;approximate&quot; uses the zero-order approximation of evaluating the pdf at the bin center, multiplied with the bin area.  This is fast and works in higher dimensions, but can lead to biased results if the curvature of the pdf inside the bin is significant.</li><li><code>names</code> : Optional names for each parameter of the model (in order). Must have the same length as there are model parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/cost.jl#LL472-L498">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.Constant-Tuple{Float64}" href="#Minuit2.Constant-Tuple{Float64}"><code>Minuit2.Constant</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Constant(value::Float64; verbose::Int=0)</code></pre><p>Constant cost function with fixed value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/cost.jl#LL254-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.CostSum-Tuple{Vararg{CostFunction}}" href="#Minuit2.CostSum-Tuple{Vararg{CostFunction}}"><code>Minuit2.CostSum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CostSum(costs::CostFunction...; verbose::Int=0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/cost.jl#LL274-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.ExtendedBinnedNLL-Union{Tuple{F}, Tuple{AbstractArray, Union{Tuple, AbstractArray}, F}} where F&lt;:Function" href="#Minuit2.ExtendedBinnedNLL-Union{Tuple{F}, Tuple{AbstractArray, Union{Tuple, AbstractArray}, F}} where F&lt;:Function"><code>Minuit2.ExtendedBinnedNLL</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">   ExtendedBinnedNLL(bincounts::AbstractArray, binedges::Union{AbstractArray, Tuple}, cdf::Function; use_pdf=:none, verbose=0,  grad=nothing, names=())</code></pre><p>Binned extended negative log-likelihood.</p><p>Use this if shape and normalization of the fitted PDF are of interest and the data is binned. This cost function works with normal and weighted histograms. The histogram can be one- or multi-dimensional.</p><p>The cost function works for both weighted data. The cost function assumes that the weights are independent of the data.</p><p>The cost function has a minimum value that is asymptotically chi2-distributed. It is constructed from the log-likelihood assuming a poisson distribution and using the saturated model as a reference.</p><p><strong>Arguments</strong></p><ul><li><code>bincounts::AbstractArray</code> : Histogram counts. If this is an array with dimension D, where D is the number of histogram axes.</li><li><code>xe::Union{AbstractArray, Tuple}</code> : Bin edge locations, must be len(n) + 1, where n is the number of bins.  If the histogram has more than one axis, xe must be a collection of the bin edge locations along each axis.</li><li><code>cdf::Function</code> : Cumulative density function of the form f(xe, par0, par1, ..., parN),  where xe is a bin edge and par0, ... are model parameters. The corresponding density must be normalized to unity   over the space covered by the histogram. If the model is multivariate, xe must be an array-like with shape (D, N),  where D is the dimension and N is the number of points where the model is evaluated.</li><li><code>verbose::Int</code> : Verbosity level. 0: is no output.</li><li><code>grad::Union{Function, Nothing} : Optionally pass the gradient of the</code>cdf``. Has the same calling signature like the cdf,   but must return an array with the shape (K,), where K is the number of parameters. The gradient can be used by Minuit to   improve or speed up convergence.</li><li><code>use_pdf::Symbol</code>: Either <code>:none</code>, <code>:numerical</code>, or <code>:approximate</code>. If the model cdf is not available, but the model pdf is,   this option can be set to &quot;numerical&quot; or &quot;approximate&quot; to compute the integral of the pdf over the bin. The option &quot;numerical&quot;   uses numerical integration, which is accurate but computationally expensive and only supported for 1D histograms. The  option &quot;approximate&quot; uses the zero-order approximation of evaluating the pdf at the bin center, multiplied with the bin area.  This is fast and works in higher dimensions, but can lead to biased results if the curvature of the pdf inside the bin is significant.</li><li><code>names</code> : Optional names for each parameter of the model (in order). Must have the same length as there are model parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/cost.jl#LL564-L599">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.ExtendedUnbinnedNLL-Union{Tuple{F}, Tuple{AbstractArray, F}} where F&lt;:Function" href="#Minuit2.ExtendedUnbinnedNLL-Union{Tuple{F}, Tuple{AbstractArray, F}} where F&lt;:Function"><code>Minuit2.ExtendedUnbinnedNLL</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExtendedUnbinnedNLL(data::AbstractArray, scaled_pdf::Function; log=false, verbose=0, mask=nothing, grad=nothing, names=())</code></pre><p>Unbinned extended negative log-likelihood.</p><p>Use this if shape and normalization of the fitted PDF are of interest and the original unbinned data is available. The data can be one- or multi-dimensional.</p><p><strong>Arguments</strong></p><ul><li><code>data::AbstractArray</code> : Sample of observations. If the observations are multidimensional, data must  have the shape (D, N), where D is the number of dimensions and N the number of data points.</li><li><code>scaled_pdf::Function</code> : Probability density function of the form f(data, par0, [par1, ...]), where  data is the sample and par0, ... are model parameters. Must return a tuple (&lt;integral  over f in data window&gt;, &lt;f evaluated at data points&gt;). The first value is the density integrated over   the data window, the interval that we consider for the fit. For example, if the data are exponentially distributed, but we  fit only the interval (0, 5), then the first value is the density integrated from 0 to 5.   If the data are multivariate, data passed to f has shape (D,N), where D is the number of dimensions and N the number of data points.</li><li><code>verbose::Int</code> : Verbosity level. 0: is no output.</li><li><code>log::Bool=false</code> : Distributions of the exponential family (normal, exponential, poisson, ...)  allow one to compute the logarithm of the pdf directly, which is more  accurate and efficient than numerically computing <span>$log(pdf)$</span>. Set this  to <code>true</code>, if the model returns the logpdf instead of the pdf.</li><li><code>mask::Union{Vector{Bool}, BitVector, Nothing}</code> : Optional mask to select a subset of the data. Must have the same length as data.</li><li><code>grad::Union{Function, Nothing}</code> : Optionally pass the gradient of the pdf. Has the same calling signature like  the pdf, but must return an array with the shape (K, N), where N is the number of data points and K is the number of parameters.</li><li><code>names</code> : Optional names for each parameter of the model (in order). Must have the same length as there are model parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/cost.jl#LL403-L429">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.LeastSquares-Tuple{AbstractArray, AbstractVector, Any, Function}" href="#Minuit2.LeastSquares-Tuple{AbstractArray, AbstractVector, Any, Function}"><code>Minuit2.LeastSquares</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LeastSquares(x::AbstractArray, y::AbstractVector, yerror, model::Function; 
                 loss=:linear, verbose=0, model_grad=nothing, names=(), mask=nothing)</code></pre><p>Least-squares cost function (aka chisquare function).</p><p>Use this if you have data of the form (x, y +/- yerror), where x can be one-dimensional or multi-dimensional,  but y is always one-dimensional.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray</code> : Locations where the model is evaluated. If the model is multivariate, x must       have shape (D, N), where D is the number of dimensions and N the number of data points.</li><li><code>y::AbstractVector</code> : Observed values. Must have the same length as x.</li><li><code>yerror</code> : Estimated uncertainty of observed values. Must have same shape as y or be a  scalar, which is then broadcasted to same shape as y.</li><li><code>model::Function</code> : Function of the form f(x, par0, [par1, ...]) whose output is compared to  observed values, where x is the location and par0, ... are model parameters. If the model is multivariate,   x has shape (D,), where D is the N the number of data points.</li><li><code>loss::Union{Symbol, Function}</code> : The loss function can be modified to make the fit robust against outliers. Only `<code>:linear</code> and <code>:soft_l1</code> are currently implemented, but users can pass any loss function as this argument. It should be a monotonic, twice differentiable function,  which accepts the squared residual and returns a modified squared residual.</li><li><code>verbose::Int</code> :  Verbosity level. 0: is no output.</li><li><code>model_grad::Union{Function, Nothing}</code> : Optionally pass the gradient of the model. Has the same calling signature like the model, but must return an array with the shape (K,), where K is the number of parameters.  The gradient can be used by Minuit to improve or speed up convergence.</li><li><code>names</code> : Optional names for each parameter of the model (in order). Must have the same length as there are model parameters.</li><li><code>mask::Union{Vector{Bool}, BitVector, Nothing}</code> : Optional mask to select a subset of the data. Must have the same length as x.</li></ul><p><strong>Notes</strong></p><p>Alternative loss functions make the fit more robust against outliers by weakening the pull of outliers. The mechanical analog of a least-squares fit is a system with attractive forces. The loss function can be modified to make the fit robust against outliers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/cost.jl#LL642-L675">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.Minuit" href="#Minuit2.Minuit"><code>Minuit2.Minuit</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Minuit structure</code></pre><p><strong>Direct or calculated fields</strong></p><ul><li><code>funcname::String</code> : Name of the function</li><li><code>x0::AbstractVector</code> : Initial parameters values</li><li><code>method::Symbol</code> : The minimization algorithm to use. Possible values are <code>:migrad</code>, <code>:simplex</code></li><li><code>tolerance::Real</code> : Tolerance for the minimization. If set to 0, Minuit will use a default value.</li><li><code>precision::Union{Real,Nothing}</code> : The precision for the minimization</li><li><code>strategy::Int</code> : The strategy for the minimization (0,1(default),2). See the manual for details.</li><li><code>values</code> : The values of the parameters at the minimum</li><li><code>errors</code> : The errors of the parameters at the minimum</li><li><code>fixed</code> : The fixed status of the parameters</li><li><code>limits</code> : The limits of the parameters</li><li><code>is_valid</code> : If the minimization was successful</li><li><code>fval</code> : The function value at the minimum</li><li><code>edm</code> : The estimated distance to minimum</li><li><code>nfcn</code> : The number of function calls</li><li><code>ngrad</code> : The number of gradient calls</li><li><code>niter</code> : The number of iterations</li><li><code>npars</code> : The number of parameters</li><li><code>ndof</code> : Number of degrees of freedom</li><li><code>covariance</code> : The covariance matrix of the parameters</li><li><code>is_above_max_edm</code> : If the estimated distance to minimum is above the maximum</li><li><code>has_parameters_at_limit</code> : If any of the parameters are at the limits</li><li><code>has_accurate_covar</code> : If the covariance matrix is accurate</li><li><code>has_posdef_covar</code> : If the covariance matrix is positive definite</li><li><code>has_made_posdef_covar</code> : If the covariance matrix was made positive definite</li><li><code>hesse_failed</code> : If the Hesse algorithm failed</li><li><code>has_covariance</code> : If the covariance matrix is available</li><li><code>covariance</code> : The covariance matrix of the parameters</li><li><code>has_accurate_covar</code> : If the covariance matrix is accurate</li><li><code>has_valid_parameters</code> : If the parameters are valid</li><li><code>has_reached_call_limit</code> : If the maximum number of function calls was reached</li><li><code>minos</code> : The Minos errors</li><li><code>parameters</code> : The parameters values and errors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/api.jl#LL10-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.Minuit-Tuple{Any, Vararg{Any}}" href="#Minuit2.Minuit-Tuple{Any, Vararg{Any}}"><code>Minuit2.Minuit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Minuit(fcn, x0...; grad=nothing, error=(), errordef=1.0, names=(), limits=(), fixed=(), method=:migrad, maxfcn=0, 
            tolerance=0.1, precision=nothing, strategy=1, kwargs...)</code></pre><p>Initialize a Minuit object.</p><p>This does not start the minimization or perform any other work yet. Algorithms  are started by calling the corresponding methods.</p><p><strong>Arguments</strong></p><ul><li><code>fcn::Union{Function,CostFunction}</code> : Function to minimize. See notes for details on what kind of functions are accepted.</li><li><code>x0::AbstractArray</code> : Starting values for the minimization. See notes for details on how to set starting values.</li><li><code>grad::Union{Function,Nothing, Bool}</code> : If <code>grad</code> is a function, it must be a function that calculates the gradient and returns an iterable object with one entry for each parameter, which is the derivative of <code>fcn</code> for that parameter. If <code>nothing</code> (default), Minuit will use the gradient of the provided  cost function. If it does not exists Minuit will compute the gradient numerically. If <code>grad</code> is <code>false</code>, Minuit will not use the gradient.</li><li><code>error::AbstractArray</code> : Starting values for the errors of the parameters. If not provided, Minuit will use 0.1 for all parameters.</li><li><code>errordef::Real</code> : Error definition of the function. Minuit defines parameter errors as the change in parameter  value required to change the function value by <code>errordef</code>. Normally, for chisquared fits it is 1, and for negative log likelihood, its value is 0.5. If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4, as <code>Chi2(x+n*sigma) = Chi2(x) + n*n</code>.</li><li><code>names::Vector{String}</code> : Names of the parameters. If not provided, Minuit will try to extract the names from the function signature.</li><li><code>limits::AbstractArray</code> : Limits for the parameters. If not provided, Minuit will use no limits for all parameters.</li><li><code>fixed::AbstractArray</code> : Fixed status of the parameters. If not provided, Minuit will use <code>false</code> for all parameters. The limits are a tuple of two values, the lower and upper limit. If the parameter is fixed, the limits are set to <code>(-Inf, Inf)</code>.</li><li><code>method::Symbol</code> : The minimization algorithm to use. Possible values are <code>:migrad</code>, <code>:simplex</code></li><li><code>maxfcn::Int</code> : Maximum number of function calls. If set to 0, Minuit will use a default value.</li><li><code>tolerance::Real</code> : Tolerance for the minimization. If set to 0, Minuit will use a default value.</li><li><code>arraycall::Bool</code>: If the function takes a single argument which can be an array or takes multiple arguments. If not provided, Minuit will try to detect it via reflection. See <a href="#Minuit2.get_nargs-Tuple{Any}"><code>get_nargs</code></a>.</li><li><code>kwargs</code> : Additional keyword arguments. Starting values for the minimization as keyword arguments. See notes for details on how to set starting values.</li></ul><p><strong>Notes</strong></p><p><strong>Function to minimize</strong></p><p>By default, Minuit assumes that the callable <code>fcn</code> behaves like chi-square function, meaning that the function minimum in repeated identical random experiments is chi-square distributed up to an arbitrary additive constant. This is important for the correct error calculation. If <code>fcn</code> returns a log-likelihood, one should multiply the result with -2 to adapt it. If the function returns the negated log-likelihood, one can alternatively set the attribute <code>errordef</code> to make Minuit calculate errors properly.</p><p>Minuit reads the function signature of <code>fcn</code> to detect the number and names of the function parameters. Two kinds of function signatures are understood.</p><p>a.  Function with positional arguments.</p><p>The function has positional arguments, one for each fit parameter. Example:</p><pre><code class="nohighlight hljs">fcn(a, b, c) =  ...</code></pre><p>The parameters a, b, c must accept a real number Minuit automatically detects the parameters names in this case.</p><p>b.  Function with arguments passed as a single AbstractArray.</p><p>The function has a single argument which is an AbstractArray. Example:</p><pre><code class="nohighlight hljs">function fcn_v(x) =  ...</code></pre><p>To use this form, starting values (<code>x0</code>) needs to be passed to Minuit in form of a <code>Tuple</code> or <code>Vector</code>. In some cases, the detection may fail, and will be necessary to use the <code>names</code> keyword to set the parameter names.</p><p><strong>Parameter initialization</strong></p><p>Initial values for the minimization can be set with positional arguments or via keywords. This is best explained through an example:</p><pre><code class="nohighlight hljs">fcn(x, y) =  (x - 2)^2 + (y - 3)^2</code></pre><p>The following ways of passing starting values are equivalent:</p><pre><code class="nohighlight hljs">Minuit(fcn, x=1, y=2)
Minuit(fcn, y=2, x=1) # order is irrelevant when keywords are used ...
Minuit(fcn, [1,2])    # ... but here the order matters</code></pre><p>Positional arguments can also be used if the function has no signature:</p><pre><code class="nohighlight hljs">fcn_no_sig(args...) =  ...
Minuit(fcn_no_sig, [1,2])</code></pre><p>If the arguments are explicitly named with the <code>names</code> keyword described further below, keywords can be used for initialization:</p><pre><code class="nohighlight hljs">Minuit(fcn_no_sig, x=1, y=2, names=(&quot;x&quot;, &quot;y&quot;))  # this also works</code></pre><p>If the function accepts a single AbstractVector, then the initial values must be passed as a single array-like object:</p><pre><code class="nohighlight hljs">fcn_v(x) = return (x[1] - 2) ** 2 + (x[2] - 3) ** 2
Minuit(fcn_v, (1, 2))</code></pre><p>Setting the values with keywords is not possible in this case. Minuit deduces the number of parameters from the length of the initialization sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/api.jl#LL195-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.UnbinnedNLL-Union{Tuple{F}, Tuple{AbstractArray, F}} where F&lt;:Function" href="#Minuit2.UnbinnedNLL-Union{Tuple{F}, Tuple{AbstractArray, F}} where F&lt;:Function"><code>Minuit2.UnbinnedNLL</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnbinnedNLL(data::AbstractArray, pdf::Function; log=false, verbose=0, mask=nothing, grad=nothing, names=())</code></pre><p>Unbinned negative log-likelihood cost function.</p><p><strong>Arguments</strong></p><ul><li><code>data::AbstractArray</code> : Sample of observations. If the observations are multidimensional, data must have the shape (D, N), where D is the number of dimensions and N the number of data points.</li><li><code>pdf::Function</code> : Probability density function of the form f(data, par0, [par1, ...]), where data is the data sample and par0, ... are model parameters. If the data are multivariate, data passed to f has shape (D,), where D is the number of dimensions and N the number of data points.</li><li><code>verbose::Int</code> : Verbosity level. 0: is no output (default). 1: print current args and negative log-likelihood value.</li><li><code>log::Bool=false</code> : Distributions of the exponential family (normal, exponential, poisson, ...) allow one to compute the logarithm of the pdf directly, which is more accurate and efficient than numerically computing <span>$log(pdf)$</span>. Set this to <code>true</code>, if the model returns the logpdf instead of the pdf.</li><li><code>mask::Union{Vector{Bool}, BitVector, Nothing}</code> : Optional mask to select a subset of the data. Must have the same length as data.</li><li><code>grad::Union{Function, Nothing}</code> : Optionally pass the gradient of the pdf. Has the same calling signature like the pdf, but must return an array with the shape (K, N), where N is the number of data points and K is the number of parameters. If <code>log</code> is True, the function must return the gradient of the logpdf instead of the pdf. The gradient can be used by Minuit to improve or speed up convergence and to compute the sandwich estimator for the variance of the parameter estimates.</li><li><code>names</code> : Optional names for each parameter of the model (in order). Must have the same length as there are model parameters.</li></ul><p><strong>Returns</strong></p><ul><li>Cost function object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/cost.jl#LL322-L352">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.RooFit.AbstractPdf" href="#Minuit2.RooFit.AbstractPdf"><code>Minuit2.RooFit.AbstractPdf</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractPdf</code></pre><p>Abstract type for all RooFit distributions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/roofit.jl#LL19-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.RooFit.AddPdf-Tuple{Any, Any, Any}" href="#Minuit2.RooFit.AddPdf-Tuple{Any, Any, Any}"><code>Minuit2.RooFit.AddPdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AddPdf(name, pdfs, fractions)</code></pre><p>Construct an AddPdf distribution with a name, a vector of AbstractPdf pdfs and a vector of RealVar fractions.</p><p><strong>Arguments</strong></p><ul><li><code>name::Symbol</code>: Name of the distribution.</li><li><code>pdfs::Vector{&lt;:AbstractPdf}</code>: Vector of AbstractPdf pdfs.</li><li><code>fractions::Vector{&lt;:RealVar}</code>: Vector of RealVar fractions or coefficients.<ul><li>If the number of pdfs is equal to the number of fractions, the fractions represent absolute populations.</li><li>If the number of pdfs is equal to the number of fractions + 1, the fractions represent recursive fractions.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li>An AddPdf distribution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/roofit.jl#LL370-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.RooFit.AddPdf-Tuple{Any, Minuit2.RooFit.AbstractPdf, Minuit2.RooFit.AbstractPdf, Minuit2.RooFit.RealVar}" href="#Minuit2.RooFit.AddPdf-Tuple{Any, Minuit2.RooFit.AbstractPdf, Minuit2.RooFit.AbstractPdf, Minuit2.RooFit.RealVar}"><code>Minuit2.RooFit.AddPdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AddPdf(name, pdf1::AbstractPdf, pdf2::AbstractPdf, fraction::RealVar)</code></pre><p>Construct an AddPdf distribution with a name, two AbstractPdf pdfs and a RealVar fraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/roofit.jl#LL408-L412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.RooFit.ArgusPdf" href="#Minuit2.RooFit.ArgusPdf"><code>Minuit2.RooFit.ArgusPdf</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ArgusPdf(name, m, m₀, c, p)</code></pre><p>ArgusPdf describes the ARGUS background shape.</p><p><span>$\mathrm{Argus}(m, m_0, c, p) = \mathcal{N} \cdot m \cdot \left[ 1 - \left( \frac{m}{m_0} \right)^2 \right]^p   \cdot \exp\left[ c \cdot \left(1 - \left(\frac{m}{m_0}\right)^2 \right) \right]$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/roofit.jl#LL298-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.RooFit.Chebyshev-Tuple{Any, Any, Any}" href="#Minuit2.RooFit.Chebyshev-Tuple{Any, Any, Any}"><code>Minuit2.RooFit.Chebyshev</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Chebyshev(name, x, coeffs)</code></pre><p>Construct a Chebyshev distribution with a name, a RealVar x and a vector of coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/roofit.jl#LL333-L337">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.RooFit.DataSet" href="#Minuit2.RooFit.DataSet"><code>Minuit2.RooFit.DataSet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DataSet</code></pre><p>DataSet is a container for a set of data points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/roofit.jl#LL145-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.RooFit.Exponential-Tuple{Any, Any, Any}" href="#Minuit2.RooFit.Exponential-Tuple{Any, Any, Any}"><code>Minuit2.RooFit.Exponential</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Exponential(name, x, c)</code></pre><p>Construct an Exponential distribution with a <code>name</code>, a RealVar <code>x</code> and a RealVar <code>c</code>.</p><p><span>$\mathrm{Exponential}(x, c) = \mathcal{N} \cdot \exp(c\cdot x)$</span>,  where <span>$\mathcal{N}$</span> is a normalization constant that depends on the range and values of the arguments</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/roofit.jl#LL259-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.RooFit.FitResult" href="#Minuit2.RooFit.FitResult"><code>Minuit2.RooFit.FitResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FitResult</code></pre><p>FitResult is a container for the result of a fit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/roofit.jl#LL156-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.RooFit.Gaussian-NTuple{4, Any}" href="#Minuit2.RooFit.Gaussian-NTuple{4, Any}"><code>Minuit2.RooFit.Gaussian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Gaussian(name, x, μ, σ)</code></pre><p>Construct a Gaussian distribution with a name, a RealVar x, a RealVar μ and a RealVar σ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/roofit.jl#LL226-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.RooFit.RealVar" href="#Minuit2.RooFit.RealVar"><code>Minuit2.RooFit.RealVar</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RealVar{T&lt;:Real}</code></pre><p>Entity to represent a real variable with a name, value, limits and number of bins.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/roofit.jl#LL79-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.RooFit.RealVar-Union{Tuple{Any}, Tuple{T}, Tuple{Any, T}, Tuple{Any, T, T}} where T&lt;:Real" href="#Minuit2.RooFit.RealVar-Union{Tuple{Any}, Tuple{T}, Tuple{Any, T}, Tuple{Any, T, T}} where T&lt;:Real"><code>Minuit2.RooFit.RealVar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RealVar(name, value=0.;  limits=(-Inf,Inf), nbins=0)</code></pre><p>Construct a RealVar with a name, value, limits and number of bins.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/roofit.jl#LL92-L96">source</a></section></article><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.FCN" href="#Minuit2.FCN"><code>Minuit2.FCN</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FCN(cost::CostFunction, grad=true)</code></pre><p>Create a JuliaFcn object from a CostFunction.</p><p><strong>Arguments</strong></p><ul><li><code>fnc::CostFunction</code> : The CostFunction to minimize.</li><li><code>grad::Bool=true</code> : If <code>true</code>, the gradient of the cost function is used. If <code>false</code>, the gradient is not used. </li></ul><p><strong>Returns</strong></p><ul><li><code>JuliaFcn</code> : A JuliaFcn object inheriting from the abstract C++ class <code>Minuit::FCNBase</code>that can be used in Minuit.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/api.jl#LL135-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.FCN" href="#Minuit2.FCN"><code>Minuit2.FCN</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FCN(fnc, grad=nothing, arraycall=false, errordef=1.0)</code></pre><p>Create a JuliaFcn object from a Julia function <code>fnc</code> and its gradient <code>grad</code>.</p><p><strong>Arguments</strong></p><ul><li><code>fnc::Function</code> : The Julia function to minimize. It can either accept a set of discrete arguments or a single argument of type <code>AbstractVector</code>.   This is decided in conjunction with the argument <code>arraycall</code>.</li><li><code>grad::Function=nothing</code>; Gradient Julia function. The input arguments follow the same as for <code>fcn</code> and it returns a <code>Vector</code>, of length the number of parameters, with the gradients.</li><li><code>arraycall::Bool=false</code> : If <code>true</code>, the function <code>fcn</code> accepts a single argument of type <code>AbstractVector</code>. If <code>false</code>, the function accepts a set of discrete arguments.</li><li><code>errordef::Real=1.0</code> : Error definition of the function. Minuit defines parameter errors as the change in parameter   value required to change the function value by <code>errordef</code>. Normally, for chisquared fits it is 1, and for negative log likelihood, its value is 0.5. </li></ul><p><strong>Returns</strong></p><ul><li><code>JuliaFcn</code> : A JuliaFcn object inheriting from the abstract C++ class <code>Minuit::FCNBase</code>that can be used in Minuit.</li></ul><p><strong>Usage</strong></p><pre><code class="language-julia hljs">fcn(x, y) = (x - 2)^2 + (y - 3)^2
grad(x, y) = [2*(x - 2), 2*(y - 3)]
jf = FCN(fcn, grad)

jf(1.0, 1.0)  # returns 5.0
jf.grad(1.0, 1.0)  # returns [-2.0, -4.0]

jf.nfcn # returns the number of function calls
jf.ngrad # returns the number of gradient calls

jf.has_gradient # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/api.jl#LL70-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.chi2-Tuple{Any, Any, Any}" href="#Minuit2.chi2-Tuple{Any, Any, Any}"><code>Minuit2.chi2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chi2(y, ye, ym)</code></pre><p>Compute (potentially) chi2-distributed cost.</p><p>The value returned by this function is chi2-distributed, if the observed values are normally distributed around the expected values with the provided standard deviations.</p><p><strong>Arguments</strong></p><ul><li><code>y</code> : Observed values.</li><li><code>ye</code> : Uncertainties of values.</li><li><code>ym</code> : Expected values.</li></ul><p><strong>Returns</strong></p><ul><li>Value of cost function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/cost.jl#LL25-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.chi2_grad-NTuple{4, Any}" href="#Minuit2.chi2_grad-NTuple{4, Any}"><code>Minuit2.chi2_grad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chi2_grad(y, ye, ym, gym)</code></pre><p>Compute gradient of function <code>chi2</code>.</p><p><strong>Arguments</strong></p><ul><li><code>y</code> : Observed values.</li><li><code>ye</code> : Uncertainties of values.</li><li><code>ym</code> : Expected values.</li><li><code>gym</code> : Gradient of ym with respect to K model parameters.</li></ul><p><strong>Returns</strong></p><ul><li>Gradient of cost function with respect to model parameters.  </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/cost.jl#LL49-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.contour-Tuple{Minuit, Any, Any}" href="#Minuit2.contour-Tuple{Minuit, Any, Any}"><code>Minuit2.contour</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">contour(m::Minuit, x, y; size=50, bound=2, grid=nothing, subtract_min=false)</code></pre><p>Get a 2D contour of the function around the minimum.</p><p>It computes the contour via a function scan over two parameters, while keeping all other parameters fixed. The related :meth:<code>mncontour</code> works differently: for each pair of parameter values in the scan, it minimises the function with the respect to all other parameters.</p><p>This method is useful to inspect the function near the minimum to detect issues (the contours should look smooth). It is not a confidence region unless the function only has two parameters. Use :meth:<code>mncontour</code> to compute confidence regions.</p><p><strong>Arguments</strong></p><ul><li><code>x</code> : First parameter for scan (name or index).</li><li><code>y</code>`: Second parameter for scan (name or index).</li><li><code>size=50</code> : Number of scanning points per parameter (Default: 50). It can be tuple <code>(nx,ny)</code> as           the number of scanning points per parameter. Ignored if <code>grid</code> is set.</li><li><code>bound=2</code> : Either ((v1min,v1max),(v2min,v2max)) or the number of <code>sigma</code>s to scan symmetrically from minimum.</li><li><code>grid::Tuple{AbstractVector,AbstractVector} : Grid points to scan over. If</code>grid<span>$is set, `size$</span> and <code>bound</code> are ignored.</li><li><code>subtract_min::Bool=false</code> : Subtract minimum from return values</li></ul><p><strong>Returns</strong></p><ul><li>Tuple(<code>xv</code>, <code>yv</code>, <code>zv</code>) : Tuple of 1D arrays with the x and y values and a 2D array with the function values. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/api.jl#LL624-L650">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.get_nargs-Tuple{Any}" href="#Minuit2.get_nargs-Tuple{Any}"><code>Minuit2.get_nargs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_nargs(f)::Int</code></pre><p>Returns the number of arguments of the function <code>f</code>. The first argument is the function itself, so the number of arguments is <code>length(m.sig.parameters)-1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/util.jl#LL315-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.hesse!-Tuple{Minuit}" href="#Minuit2.hesse!-Tuple{Minuit}"><code>Minuit2.hesse!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hesse!(m::Minuit, ncall::Int=0)</code></pre><p>Run Hesse algorithm to compute asymptotic errors.</p><p>The Hesse method estimates the covariance matrix by inverting the matrix of <a href="https://en.wikipedia.org/wiki/Hessian_matrix">second derivatives (Hesse matrix) at the minimum</a>.  To get parameters correlations, you need to use this. The Minos algorithm is another way to  estimate parameter uncertainties, see function <code>minos</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ncall::Int=0</code> : Approximate upper limit for the number of calls made by the Hesse algorithm. If set to 0, use the adaptive heuristic from the Minuit2 library.</li></ul><p><strong>Notes</strong></p><p>The covariance matrix is asymptotically (in large samples) valid. By valid we mean that confidence intervals constructed from the errors contain the true value with a well-known coverage probability (68 % for each interval). In finite samples, this is likely to be true if your cost function looks like a hyperparabola around the minimum.</p><p>In practice, the errors very likely have correct coverage if the results from Minos and Hesse methods agree. It is possible to construct artificial functions where this rule is violated, but in practice it should always work.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/api.jl#LL496-L520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.matrix-Tuple{Minuit}" href="#Minuit2.matrix-Tuple{Minuit}"><code>Minuit2.matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matrix(m::Minuit; correlation=false)</code></pre><p>Get the covariance matrix of the parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/api.jl#LL477-L481">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.migrad!" href="#Minuit2.migrad!"><code>Minuit2.migrad!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">migrad!(m::Minuit, strategy=1; ncall=0)</code></pre><p>Run Migrad minimization.</p><p>Migrad from the Minuit2 library is a robust minimisation algorithm which earned its reputation in 40+ years of almost exclusive usage in high-energy physics. How Migrad works is described in the <a href>Minuit</a> paper. It uses first and approximate second derivatives to achieve quadratic convergence near the minimum.</p><p><strong>Parameters</strong></p><ul><li><code>m::Minuit</code> : The Minuit object to minimize.</li><li><code>strategy::Int</code> : The minimization strategy. The default value is 1, which is   the recommended value for most cases. The value 0 is faster, but less   reliable. The value 2 is slower, but more reliable. The value 3 or higher is slower,   but even more reliable.</li></ul><p><strong>Keyword Parameters</strong></p><ul><li><code>ncall::Int=0</code> : Approximate upper limit for the number of calls. If set to 0, use the adaptive heuristic from the Minuit2 library.</li></ul><p>The following two parameters controls the behavior of <a href="#Minuit2.robust_low_level_fit-NTuple{8, Any}"><code>robust_low_level_fit</code></a>, which essentially tries to restart Migrad procedure when it fails to converge after the first iteration:</p><ul><li><code>iterate::Int=5</code> : Number of iterations to run the minimization. Default is 5.</li><li><code>use_simplex::Bool=true</code> : If <code>true</code>, use the simplex algorithm in retry to find the minimum. If <code>false</code>, use the migrad algorithm.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/api.jl#LL367-L391">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.minos!-Tuple{Minuit}" href="#Minuit2.minos!-Tuple{Minuit}"><code>Minuit2.minos!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minos!(m::Minuit, name::String)</code></pre><p>Run Minos algorithm to compute asymmetric errors for a single parameter.</p><p>The Minos algorithm uses the profile likelihood method to compute (generally asymmetric) confidence intervals. It scans the negative log-likelihood or (equivalently) the least-squares cost function around the minimum to construct a confidence interval.</p><p><strong>Arguments</strong></p><ul><li><code>m::Minuit</code> : The Minuit object to minimize.</li><li><code>parameters::AbstractVector{String}</code> : Names of the parameters to compute the Minos errors for.</li><li><code>cl::Number</code> : Confidence level of the interval. If not set, a standard 68 %  interval is computed (default). If 0 &lt; cl &lt; 1, the value is interpreted as  the confidence level (a probability). For convenience, values cl &gt;= 1 are  interpreted as the probability content of a central symmetric interval  covering that many standard deviations of a normal distribution. For  example, cl=1 is interpreted as 68.3 %, and cl=2 is 84.3 %, and so on. Using  values other than 0.68, 0.9, 0.95, 0.99, 1, 2, 3, 4, 5 require the scipy module.</li><li><code>ncall::Int</code> : Limit the number of calls made by Minos. If 0, an adaptive internal  heuristic of the Minuit2 library is used (Default: 0).</li></ul><p><strong>Notes</strong></p><p>Asymptotically (large samples), the Minos interval has a coverage probability equal to the given confidence level. The coverage probability is the probability for the interval to contain the true value in repeated identical experiments.</p><p>The interval is invariant to transformations and thus not distorted by parameter limits, unless the limits intersect with the confidence interval. As a rule-of-thumb: when the confidence intervals computed with the Hesse and Minos algorithms differ strongly, the Minos intervals are preferred. Otherwise, Hesse intervals are preferred.</p><p>Running Minos is computationally expensive when there are many fit parameters. Effectively, it scans over one parameter in small steps and runs a full minimisation for all other parameters of the cost function for each scan point. This requires many more function evaluations than running the Hesse algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/api.jl#LL532-L570">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.mncontour-Tuple{Minuit, Any, Any}" href="#Minuit2.mncontour-Tuple{Minuit, Any, Any}"><code>Minuit2.mncontour</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nmcontour(x, y; cl=0.68, size=50, interpolated=0, ncall=0, iterate=5, use_simplex=true)</code></pre><p>Get 2D Minos confidence region.</p><p>This scans over two parameters and minimises all other free parameters for each scan point. This scan produces a statistical confidence region according to the <a href="https://en.wikipedia.org/wiki/Likelihood_function">profile likelihood method</a> with a confidence level <code>cl</code>, which is asymptotically equal to the coverage probability of the confidence region according to <a href="https://en.wikipedia.org/wiki/Wilks%27_theorem">Wilks&#39; theorem</a>. Note that 1D projections of the 2D confidence region are larger than 1D Minos intervals computed for the same confidence level. This is not an error, but a consequence of Wilks&#39;theorem.</p><p>The calculation is expensive since a numerical minimisation has to be performed at various points.</p><p><strong>Arguments</strong></p><ul><li><code>x</code> : Variable name of the first parameter.</li><li><code>y</code> : Variable name of the second parameter.</li><li><code>cl::Real=0.68</code> : Confidence level of the contour. If not set a standard 68 % contour is computed (default). If 0 &lt; cl &lt; 1, the value is interpreted as the confidence level (a probability). For convenience, values cl &gt;= 1 are interpreted as the probability content of a central symmetric interval covering that many standard deviations of a normal distribution.</li><li><code>size::Int=50</code> : Number of points on the contour to find. Increasing this makes the contour smoother, but requires more computation time.</li><li><code>interpolated::Int=0</code> : Number of interpolated points on the contour. If you set this to a value larger than size, cubic spline interpolation is used to generate a smoother curve and the interpolated coordinates are returned. Values smaller than size are ignored. Good results can be obtained with size=20, interpolated=200.</li></ul><p><strong>Returns</strong></p><ul><li><code>contour::Vector(Tuple{Float64,Float64})</code> : Contour points of the form [(x1, y1)...(xn, yn)].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/api.jl#LL690-L723">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.mnprofile-Tuple{Minuit, Any}" href="#Minuit2.mnprofile-Tuple{Minuit, Any}"><code>Minuit2.mnprofile</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mnprofile(m::Minuit, var; size=30, bound=2, grid=nothing, subtract_min=false, 
               ncall=0, iterate=5, use_simplex=true)</code></pre><p>Get Minos profile over a specified interval.</p><p>Scans over one parameter and minimises the function with respect to all other parameters for each scan point.</p><p><strong>Arguments</strong></p><ul><li><code>var</code> : Parameter to scan over.</li><li><code>size=30</code> : Number of scanning points. Ignored if grid is set.</li><li><code>bound=2</code> : If bound is a tuple, (left, right) scanning bound, or the number of sigmas to scan symmetrically around the minimum. Ignored if grid is set.</li><li><code>grid</code> : Parameter values on which to compute the profile. If <code>grid</code> is set, <code>size</code> and  <code>bound</code> are ignored.</li><li><code>subtract_min=false</code> : If true, subtract offset so that smallest value is zero.</li><li><code>ncall=0</code> : Approximate maximum number of calls before minimization will be aborted.  If set to 0, use the adaptive heuristic from the Minuit2 library.   Note: The limit may be slightly violated, because the condition is checked only after   a full iteration of the algorithm, which usually performs several function calls.       iterate : int, optional           Automatically call Migrad up to N times if convergence was not reached           (Default: 5). This simple heuristic makes Migrad converge more often even if           the numerical precision of the cost function is low. Setting this to 1           disables the feature.       use_simplex: bool, optional           If we have to iterate, set this to True to call the Simplex algorithm before           each call to Migrad (Default: True). This may improve convergence in           pathological cases (which we are in when we have to iterate).</li></ul><p><strong>Returns</strong></p><ul><li>Tuple(<code>x</code>, <code>y</code>, <code>ok</code>) : Tuple of 1D arrays with the parameter values, function values and booleans whether the fit succeeded or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/api.jl#LL801-L834">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.multinomial_chi2-Tuple{Any, Any}" href="#Minuit2.multinomial_chi2-Tuple{Any, Any}"><code>Minuit2.multinomial_chi2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">multinomial_chi2(n, mu)</code></pre><p>Compute asymptotically chi2-distributed cost for multinomially-distributed data. See Baker &amp; Cousins, NIM 221 (1984) 437-442.</p><p><strong>Arguments</strong></p><ul><li><code>n</code> : Observed counts.</li><li><code>mu</code> Expected counts. Must satisfy sum(mu) == sum(n).</li></ul><p><strong>Returns</strong></p><ul><li>Cost function value.</li></ul><p><strong>Notes</strong></p><p>The implementation makes the result asymptotically chi2-distributed, which helps to maximise the numerical accuracy for Minuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/cost.jl#LL77-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.multinomial_chi2_grad-Tuple{Any, Any, Any}" href="#Minuit2.multinomial_chi2_grad-Tuple{Any, Any, Any}"><code>Minuit2.multinomial_chi2_grad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">multinomial_chi2_grad(n, mu, gmu)</code></pre><p>Compute gradient of function <code>multinomial_chi2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/cost.jl#LL98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.poisson_chi2-Tuple{Any, Any}" href="#Minuit2.poisson_chi2-Tuple{Any, Any}"><code>Minuit2.poisson_chi2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poisson_chi2(n, mu)</code></pre><p>Compute asymptotically chi2-distributed cost for Poisson-distributed data. See Baker &amp; Cousins, NIM 221 (1984) 437-442.</p><p><strong>Arguments</strong></p><ul><li><code>n</code> : Observed counts.</li><li><code>mu</code> : Expected counts per bin.</li></ul><p><strong>Returns</strong></p><ul><li>Cost function value.</li></ul><p><strong>Notes</strong></p><p>The implementation makes the result asymptotically chi2-distributed, which helps to maximise the numerical accuracy for Minuit.</p><p>If sum(mu) == sum(n), the result is equal to <code>multinomial_chi2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/cost.jl#LL107-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.poisson_chi2_grad-Tuple{Any, Any, Any}" href="#Minuit2.poisson_chi2_grad-Tuple{Any, Any, Any}"><code>Minuit2.poisson_chi2_grad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poisson_chi2_grad(n, mu, gmu)</code></pre><p>Compute gradient of function <code>poisson_chi2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/cost.jl#LL131-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.profile-Tuple{Minuit, Any}" href="#Minuit2.profile-Tuple{Minuit, Any}"><code>Minuit2.profile</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">profile(m::Minuit, var; size=100, bound=2, grid=nothing, subtract_min=false)</code></pre><p>Calculate 1D cost function profile over a range.</p><p>A 1D scan of the cost function around the minimum, useful to inspect the minimum. For a fit with several free parameters this is not the same as the Minos profile computed by <code>mncontour</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Minuit</code> : The Minuit object to minimize.</li><li><code>var</code> : The parameter to scan over (name or index).</li><li><code>size=100</code> : Number of scanning points. Ignored if <code>grid</code> is set.</li><li><code>bound=2</code> : Number of <code>sigma</code>s to scan symmetrically around the minimum. Ignored if <code>grid</code> is set.</li><li><code>grid::AbstractVector</code> : Grid points to scan over. If <code>grid</code> is set, <code>size</code> and <code>bound</code> are ignored.</li><li><code>subtract_min::Bool=false</code> : Subtract minimum from return values.</li></ul><p><strong>Returns</strong></p><ul><li>Tuple(<code>x</code>, <code>y</code>) : Tuple of 1D arrays with the parameter values and the function values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/api.jl#LL755-L774">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.robust_low_level_fit-NTuple{8, Any}" href="#Minuit2.robust_low_level_fit-NTuple{8, Any}"><code>Minuit2.robust_low_level_fit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">robust_low_level_fit(fcn, state, ncall, strategy, tolerance, precision, iterate, use_simplex)</code></pre><p>A meta algorithm that:</p><ol><li>runs Migrad with user-specified configs (such as strategy and tolerance)</li><li>checks if we converged</li><li>if not, sets strategy=2, and start running N more iterations</li><li>in each additional iteration, if <code>use_simplex</code>, runs SIMPLEX (again, think NelderMead) first, followed by a Migrad</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/api.jl#LL870-L879">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.scan!" href="#Minuit2.scan!"><code>Minuit2.scan!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scan!(m::Minuit, maxfcn = 0, strategy=1)</code></pre><p>Run Scan algorithm to find the minimum. Thus is a brute force algorithm that scans the function in a hypercube around the initial values. The values must be within the limits.</p><p><strong>Arguments</strong></p><ul><li><code>m::Minuit</code> : The Minuit object to minimize.</li><li><code>maxfcn::Int=0</code> : Maximum number of function calls. If set to 0, Minuit will use a default value.</li><li><code>strategy::Int=1</code> : The minimization strategy. The default value is 1, which is   the recommended value for most cases. The value 0 is faster, but less   reliable. The value 2 is slower, but more reliable. The value 3 or higher is slower,   but even more reliable.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/api.jl#LL437-L450">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.simplex!" href="#Minuit2.simplex!"><code>Minuit2.simplex!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simplex!(m::Minuit, strategy=1)</code></pre><p>Run Simplex minimization.</p><p><strong>Parameters</strong></p><ul><li><code>m::Minuit</code> : The Minuit object to minimize.</li><li><code>strategy::Int</code> : The minimization strategy. The default value is 1, which is   the recommended value for most cases. The value 0 is faster, but less   reliable. The value 2 is slower, but more reliable. The value 3 or higher is slower,   but even more reliable.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/api.jl#LL413-L424">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.soft_l1_cost-Tuple{Any, Any, Any}" href="#Minuit2.soft_l1_cost-Tuple{Any, Any, Any}"><code>Minuit2.soft_l1_cost</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">soft_l1_cost(y, ye, ym)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/cost.jl#LL44-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.soft_l1_cost_grad-NTuple{4, Any}" href="#Minuit2.soft_l1_cost_grad-NTuple{4, Any}"><code>Minuit2.soft_l1_cost_grad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">soft_l1_cost_grad(y, ye, ym, gym)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/cost.jl#LL65-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.RooFit.ConstVar-Union{Tuple{T}, Tuple{Any, T}} where T&lt;:Real" href="#Minuit2.RooFit.ConstVar-Union{Tuple{T}, Tuple{Any, T}} where T&lt;:Real"><code>Minuit2.RooFit.ConstVar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConstVar(name, value=0.)</code></pre><p>Construct a ConstVar with a name ans value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/roofit.jl#LL129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.RooFit.fitTo-Tuple{Minuit2.RooFit.AbstractPdf, Any}" href="#Minuit2.RooFit.fitTo-Tuple{Minuit2.RooFit.AbstractPdf, Any}"><code>Minuit2.RooFit.fitTo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fitTo(d::AbstractPdf, data)</code></pre><p>Fit a distribution <code>d</code> to a data set <code>data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/roofit.jl#LL166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.RooFit.generate-Tuple{Minuit2.RooFit.AbstractPdf, Int64}" href="#Minuit2.RooFit.generate-Tuple{Minuit2.RooFit.AbstractPdf, Int64}"><code>Minuit2.RooFit.generate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate(d::AbstractPdf, n::Integer=1000; nbins=0)</code></pre><p>Generate <code>n</code> random numbers from a distribution <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/66926755e657ec5325a37fc2661da691bc33c2f2/src/roofit.jl#LL58-L62">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../tutorials/introduction/">Introduction to Minuit2.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.3 on <span class="colophon-date" title="Thursday 15 May 2025 15:03">Thursday 15 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
