<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · Minuit2.jl</title><meta name="title" content="Public API · Minuit2.jl"/><meta property="og:title" content="Public API · Minuit2.jl"/><meta property="twitter:title" content="Public API · Minuit2.jl"/><meta name="description" content="Documentation for Minuit2.jl."/><meta property="og:description" content="Documentation for Minuit2.jl."/><meta property="twitter:description" content="Documentation for Minuit2.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Minuit2.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Public API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/introduction/">Introduction to Minuit2.jl</a></li></ul></li></ul></li><li><a class="tocitem" href="../release_notes/">Release Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Public API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaHEP/Minuit2.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaHEP/Minuit2.jl/blob/main/docs/src/api.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-Documentation"><a class="docs-heading-anchor" href="#Public-Documentation">Public Documentation</a><a id="Public-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Documentation" title="Permalink"></a></h1><p>Documentation for <code>Minuit2.jl</code> public interface.</p><hr/><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Minuit2.Minuit"><code>Minuit2.Minuit</code></a></li><li><a href="#Minuit2.Minuit"><code>Minuit2.Minuit</code></a></li></ul><ul><li><a href="#Minuit2.FCN"><code>Minuit2.FCN</code></a></li><li><a href="#Minuit2.contour-Tuple{Minuit, Any, Any}"><code>Minuit2.contour</code></a></li><li><a href="#Minuit2.hesse!-Tuple{Minuit}"><code>Minuit2.hesse!</code></a></li><li><a href="#Minuit2.matrix-Tuple{Minuit}"><code>Minuit2.matrix</code></a></li><li><a href="#Minuit2.migrad!"><code>Minuit2.migrad!</code></a></li><li><a href="#Minuit2.minos!-Tuple{Minuit}"><code>Minuit2.minos!</code></a></li><li><a href="#Minuit2.mncontour-Tuple{Minuit, Any, Any}"><code>Minuit2.mncontour</code></a></li><li><a href="#Minuit2.mnprofile-Tuple{Minuit, Any}"><code>Minuit2.mnprofile</code></a></li><li><a href="#Minuit2.profile-Tuple{Minuit, Any}"><code>Minuit2.profile</code></a></li></ul><hr/><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><p>This is the list of all types and functions defined for Minuit2</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.Minuit" href="#Minuit2.Minuit"><code>Minuit2.Minuit</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Minuit(fcn, x0=(); grad=nothing, error=(), errordef=1.0, names=(), method=:migrad, maxfcn=0, tolerance=0, strategy=1,  kwargs...)</code></pre><p>Initialize a Minuit object.</p><p>This does not start the minimization or perform any other work yet. Algorithms  are started by calling the corresponding methods.</p><p><strong>Arguments</strong></p><ul><li><code>fcn::Function</code> : Function to minimize. See notes for details on what kind of functions are accepted.</li><li><code>x0::AbstractArray</code> : Starting values for the minimization. See notes for details on how to set starting values.</li><li><code>grad::Union{Function,Nothing}</code> : If <code>grad</code> is a function, it must be a function that calculates the gradient and returns an iterable object with one entry for each parameter, which is the derivative of <code>fcn</code> for that parameter. If <code>nothing</code> (default), Minuit will compute the gradient numerically.</li><li><code>error::AbstractArray</code> : Starting values for the errors of the parameters. If not provided, Minuit will use 0.1 for all parameters.</li><li><code>errordef::Real</code> : Error definition of the function. Minuit defines parameter errors as the change in parameter  value required to change the function value by <code>errordef</code>. Normally, for chisquared fits it is 1, and for negative log likelihood, its value is 0.5. If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4, as <code>Chi2(x+n*sigma) = Chi2(x) + n*n</code>.</li><li><code>names::Sequence{String}</code> : Names of the parameters. If not provided, Minuit will try to extract the names from the function signature.</li><li><code>method::Symbol</code> : The minimization algorithm to use. Possible values are <code>:migrad</code>, <code>:simplex</code></li><li><code>maxfcn::Int</code> : Maximum number of function calls. If set to 0, Minuit will use a default value.</li><li><code>tolerance::Real</code> : Tolerance for the minimization. If set to 0, Minuit will use a default value.</li><li><code>kwargs</code> : Additional keyword arguments. Starting values for the minimization as keyword arguments. See notes for details on how to set starting values.</li></ul><p><strong>Notes</strong></p><p><strong>Function to minimize</strong></p><p>By default, Minuit assumes that the callable <code>fcn</code> behaves like chi-square function, meaning that the function minimum in repeated identical random experiments is chi-square distributed up to an arbitrary additive constant. This is important for the correct error calculation. If <code>fcn</code> returns a log-likelihood, one should multiply the result with -2 to adapt it. If the function returns the negated log-likelihood, one can alternatively set the attribute <code>errordef</code> to make Minuit calculate errors properly.</p><p>Minuit reads the function signature of <code>fcn</code> to detect the number and names of the function parameters. Two kinds of function signatures are understood.</p><p>a.  Function with positional arguments.</p><p>The function has positional arguments, one for each fit parameter. Example:</p><pre><code class="nohighlight hljs">fcn(a, b, c) =  ...</code></pre><p>The parameters a, b, c must accept a real number Minuit automatically detects the parameters names in this case.</p><p>b.  Function with arguments passed as a single AbstractArray.</p><p>The function has a single argument which is an AbstractArray. Example:</p><pre><code class="nohighlight hljs">function fcn_v(x) =  ...</code></pre><p>To use this form, starting values (<code>x0</code>) needs to be passed to Minuit in form of a <code>Tuple</code> or <code>Vector</code>. In some cases, the detection may fail, and will be necessary to use the <code>names</code> keyword to set the parameter names.</p><p><strong>Parameter initialization</strong></p><p>Initial values for the minimization can be set with positional arguments or via keywords. This is best explained through an example:</p><pre><code class="nohighlight hljs">fcn(x, y) =  (x - 2)^2 + (y - 3)^2</code></pre><p>The following ways of passing starting values are equivalent:</p><pre><code class="nohighlight hljs">Minuit(fcn, x=1, y=2)
Minuit(fcn, y=2, x=1) # order is irrelevant when keywords are used ...
Minuit(fcn, [1,2])    # ... but here the order matters</code></pre><p>Positional arguments can also be used if the function has no signature:</p><pre><code class="nohighlight hljs">fcn_no_sig(args...) =  ...
Minuit(fcn_no_sig, [1,2])</code></pre><p>If the arguments are explicitly named with the <code>names</code> keyword described further below, keywords can be used for initialization:</p><pre><code class="nohighlight hljs">Minuit(fcn_no_sig, x=1, y=2, names=(&quot;x&quot;, &quot;y&quot;))  # this also works</code></pre><p>If the function accepts a single AbstractVector, then the initial values must be passed as a single array-like object:</p><pre><code class="nohighlight hljs">fcn_v(x) = return (x[1] - 2) ** 2 + (x[2] - 3) ** 2
Minuit(fcn_v, (1, 2))</code></pre><p>Setting the values with keywords is not possible in this case. Minuit deduces the number of parameters from the length of the initialization sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/6e6df931c8f911544c85b4362a8895cb56fd2b96/src/api.jl#LL76-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.Minuit" href="#Minuit2.Minuit"><code>Minuit2.Minuit</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Minuit</code></pre><p>Minuit object to perform minimization. It keeps track of the function to minimize, the parameters, and the minimization results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/6e6df931c8f911544c85b4362a8895cb56fd2b96/src/api.jl#LL10-L15">source</a></section></article><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.FCN" href="#Minuit2.FCN"><code>Minuit2.FCN</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FCN(fnc, grad=nothing, arraycall=false, errordef=1.0)</code></pre><p>Create a JuliaFcn object from a Julia function <code>fnc</code> and its gradient <code>grad</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/6e6df931c8f911544c85b4362a8895cb56fd2b96/src/api.jl#LL37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.contour-Tuple{Minuit, Any, Any}" href="#Minuit2.contour-Tuple{Minuit, Any, Any}"><code>Minuit2.contour</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">contour(m::Minuit, x, y; size=50, bound=2, grid=nothing, subtract_min=false)</code></pre><p>Get a 2D contour of the function around the minimum.</p><p>It computes the contour via a function scan over two parameters, while keeping all other parameters fixed. The related :meth:<code>mncontour</code> works differently: for each pair of parameter values in the scan, it minimises the function with the respect to all other parameters.</p><p>This method is useful to inspect the function near the minimum to detect issues (the contours should look smooth). It is not a confidence region unless the function only has two parameters. Use :meth:<code>mncontour</code> to compute confidence regions.</p><p><strong>Arguments</strong></p><ul><li><code>x</code> : First parameter for scan (name or index).</li><li><code>y</code>`: Second parameter for scan (name or index).</li><li><code>size=50</code> : Number of scanning points per parameter (Default: 50). It can be tuple <code>(nx,ny)</code> as           the number of scanning points per parameter. Ignored if <code>grid</code> is set.</li><li><code>bound=2</code> : Either ((v1min,v1max),(v2min,v2max)) or the number of <code>sigma</code>s to scan symmetrically from minimum.</li><li><code>grid::Tuple{AbstractVector,AbstractVector} : Grid points to scan over. If</code>grid<span>$is set, `size$</span> and <code>bound</code> are ignored.</li><li><code>subtract_min::Bool=false</code> : Subtract minimum from return values</li></ul><p><strong>Returns</strong></p><ul><li>Tuple(<code>xv</code>, <code>yv</code>, <code>zv</code>) : Tuple of 1D arrays with the x and y values and a 2D array with the function values. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/6e6df931c8f911544c85b4362a8895cb56fd2b96/src/api.jl#LL389-L415">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.hesse!-Tuple{Minuit}" href="#Minuit2.hesse!-Tuple{Minuit}"><code>Minuit2.hesse!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hesse!(m::Minuit, ncall::Int=0)</code></pre><p>Run Hesse algorithm to compute asymptotic errors.</p><p>The Hesse method estimates the covariance matrix by inverting the matrix of <a href="https://en.wikipedia.org/wiki/Hessian_matrix">second derivatives (Hesse matrix) at the minimum</a>.  To get parameters correlations, you need to use this. The Minos algorithm is another way to  estimate parameter uncertainties, see function <code>minos</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ncall::Int=0</code> : Approximate upper limit for the number of calls made by the Hesse algorithm. If set to 0, use the adaptive heuristic from the Minuit2 library.</li></ul><p><strong>Notes</strong></p><p>The covariance matrix is asymptotically (in large samples) valid. By valid we mean that confidence intervals constructed from the errors contain the true value with a well-known coverage probability (68 % for each interval). In finite samples, this is likely to be true if your cost function looks like a hyperparabola around the minimum.</p><p>In practice, the errors very likely have correct coverage if the results from Minos and Hesse methods agree. It is possible to construct artificial functions where this rule is violated, but in practice it should always work.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/6e6df931c8f911544c85b4362a8895cb56fd2b96/src/api.jl#LL264-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.matrix-Tuple{Minuit}" href="#Minuit2.matrix-Tuple{Minuit}"><code>Minuit2.matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matrix(m::Minuit; correlation=false)</code></pre><p>Get the covariance matrix of the parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/6e6df931c8f911544c85b4362a8895cb56fd2b96/src/api.jl#LL245-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.migrad!" href="#Minuit2.migrad!"><code>Minuit2.migrad!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">migrad!(m::Minuit, strategy=1)</code></pre><p>Run Migrad minimization.</p><p>Migrad from the Minuit2 library is a robust minimisation algorithm which earned its reputation in 40+ years of almost exclusive usage in high-energy physics. How Migrad works is described in the <a href>Minuit</a> paper. It uses first and approximate second derivatives to achieve quadratic convergence near the minimum.</p><p><strong>Parameters</strong></p><ul><li><code>m::Minuit</code> : The Minuit object to minimize.</li><li><code>strategy::Int</code> : The minimization strategy. The default value is 1, which is   the recommended value for most cases. The value 0 is faster, but less   reliable. The value 2 is slower, but more reliable. The value 3 or higher is slower,   but even more reliable.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/6e6df931c8f911544c85b4362a8895cb56fd2b96/src/api.jl#LL209-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.minos!-Tuple{Minuit}" href="#Minuit2.minos!-Tuple{Minuit}"><code>Minuit2.minos!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minos!(m::Minuit, name::String)</code></pre><p>Run Minos algorithm to compute asymmetric errors for a single parameter.</p><p>The Minos algorithm uses the profile likelihood method to compute (generally asymmetric) confidence intervals. It scans the negative log-likelihood or (equivalently) the least-squares cost function around the minimum to construct a confidence interval.</p><p><strong>Arguments</strong></p><ul><li><code>m::Minuit</code> : The Minuit object to minimize.</li><li><code>parameters::AbstractVector{String}</code> : Names of the parameters to compute the Minos errors for.</li><li><code>cl::Number</code> : Confidence level of the interval. If not set, a standard 68 %  interval is computed (default). If 0 &lt; cl &lt; 1, the value is interpreted as  the confidence level (a probability). For convenience, values cl &gt;= 1 are  interpreted as the probability content of a central symmetric interval  covering that many standard deviations of a normal distribution. For  example, cl=1 is interpreted as 68.3 %, and cl=2 is 84.3 %, and so on. Using  values other than 0.68, 0.9, 0.95, 0.99, 1, 2, 3, 4, 5 require the scipy module.</li><li><code>ncall::Int</code> : Limit the number of calls made by Minos. If 0, an adaptive internal  heuristic of the Minuit2 library is used (Default: 0).</li></ul><p><strong>Notes</strong></p><p>Asymptotically (large samples), the Minos interval has a coverage probability equal to the given confidence level. The coverage probability is the probability for the interval to contain the true value in repeated identical experiments.</p><p>The interval is invariant to transformations and thus not distorted by parameter limits, unless the limits intersect with the confidence interval. As a rule-of-thumb: when the confidence intervals computed with the Hesse and Minos algorithms differ strongly, the Minos intervals are preferred. Otherwise, Hesse intervals are preferred.</p><p>Running Minos is computationally expensive when there are many fit parameters. Effectively, it scans over one parameter in small steps and runs a full minimisation for all other parameters of the cost function for each scan point. This requires many more function evaluations than running the Hesse algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/6e6df931c8f911544c85b4362a8895cb56fd2b96/src/api.jl#LL303-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.mncontour-Tuple{Minuit, Any, Any}" href="#Minuit2.mncontour-Tuple{Minuit, Any, Any}"><code>Minuit2.mncontour</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nmcontour(x, y; cl=0.68, size=50, interpolated=0, ncall=0, iterate=5, use_simplex=true)</code></pre><p>Get 2D Minos confidence region.</p><p>This scans over two parameters and minimises all other free parameters for each scan point. This scan produces a statistical confidence region according to the <a href="https://en.wikipedia.org/wiki/Likelihood_function">profile likelihood method</a> with a confidence level <code>cl</code>, which is asymptotically equal to the coverage probability of the confidence region according to <a href="https://en.wikipedia.org/wiki/Wilks%27_theorem">Wilks&#39; theorem</a>. Note that 1D projections of the 2D confidence region are larger than 1D Minos intervals computed for the same confidence level. This is not an error, but a consequence of Wilks&#39;theorem.</p><p>The calculation is expensive since a numerical minimisation has to be performed at various points.</p><p><strong>Arguments</strong></p><ul><li><code>x</code> : Variable name of the first parameter.</li><li><code>y</code> : Variable name of the second parameter.</li><li><code>cl::Real=0.68</code> : Confidence level of the contour. If not set a standard 68 % contour is computed (default). If 0 &lt; cl &lt; 1, the value is interpreted as the confidence level (a probability). For convenience, values cl &gt;= 1 are interpreted as the probability content of a central symmetric interval covering that many standard deviations of a normal distribution.</li><li><code>size::Int=50</code> : Number of points on the contour to find. Increasing this makes the contour smoother, but requires more computation time.</li><li><code>interpolated::Int=0</code> : Number of interpolated points on the contour. If you set this to a value larger than size, cubic spline interpolation is used to generate a smoother curve and the interpolated coordinates are returned. Values smaller than size are ignored. Good results can be obtained with size=20, interpolated=200.</li></ul><p><strong>Returns</strong></p><ul><li><code>contour::Vector(Tuple{Float64,Float64})</code> : Contour points of the form [(x1, y1)...(xn, yn)].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/6e6df931c8f911544c85b4362a8895cb56fd2b96/src/api.jl#LL455-L488">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.mnprofile-Tuple{Minuit, Any}" href="#Minuit2.mnprofile-Tuple{Minuit, Any}"><code>Minuit2.mnprofile</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mnprofile(m::Minuit, var; size=30, bound=2, grid=nothing, subtract_min=false, 
               ncall=0, iterate=5, use_simplex=true)</code></pre><p>Get Minos profile over a specified interval.</p><p>Scans over one parameter and minimises the function with respect to all other parameters for each scan point.</p><p><strong>Arguments</strong></p><ul><li><code>var</code> : Parameter to scan over.</li><li><code>size=30</code> : Number of scanning points. Ignored if grid is set.</li><li><code>bound=2</code> : If bound is a tuple, (left, right) scanning bound, or the number of sigmas to scan symmetrically around the minimum. Ignored if grid is set.</li><li><code>grid</code> : Parameter values on which to compute the profile. If <code>grid</code> is set, <code>size</code> and  <code>bound</code> are ignored.</li><li><code>subtract_min=false</code> : If true, subtract offset so that smallest value is zero.</li><li><code>ncall=0</code> : Approximate maximum number of calls before minimization will be aborted.  If set to 0, use the adaptive heuristic from the Minuit2 library.   Note: The limit may be slightly violated, because the condition is checked only after   a full iteration of the algorithm, which usually performs several function calls.       iterate : int, optional           Automatically call Migrad up to N times if convergence was not reached           (Default: 5). This simple heuristic makes Migrad converge more often even if           the numerical precision of the cost function is low. Setting this to 1           disables the feature.       use_simplex: bool, optional           If we have to iterate, set this to True to call the Simplex algorithm before           each call to Migrad (Default: True). This may improve convergence in           pathological cases (which we are in when we have to iterate).</li></ul><p><strong>Returns</strong></p><ul><li>Tuple(<code>x</code>, <code>y</code>, <code>ok</code>) : Tuple of 1D arrays with the parameter values, function values and booleans whether the fit succeeded or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/6e6df931c8f911544c85b4362a8895cb56fd2b96/src/api.jl#LL566-L599">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Minuit2.profile-Tuple{Minuit, Any}" href="#Minuit2.profile-Tuple{Minuit, Any}"><code>Minuit2.profile</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">profile(m::Minuit, var; size=100, bound=2, grid=nothing, subtract_min=false)</code></pre><p>Calculate 1D cost function profile over a range.</p><p>A 1D scan of the cost function around the minimum, useful to inspect the minimum. For a fit with several free parameters this is not the same as the Minos profile computed by <code>mncontour</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Minuit</code> : The Minuit object to minimize.</li><li><code>var</code> : The parameter to scan over (name or index).</li><li><code>size=100</code> : Number of scanning points. Ignored if <code>grid</code> is set.</li><li><code>bound=2</code> : Number of <code>sigma</code>s to scan symmetrically around the minimum. Ignored if <code>grid</code> is set.</li><li><code>grid::AbstractVector</code> : Grid points to scan over. If <code>grid</code> is set, <code>size</code> and <code>bound</code> are ignored.</li><li><code>subtract_min::Bool=false</code> : Subtract minimum from return values.</li></ul><p><strong>Returns</strong></p><ul><li>Tuple(<code>x</code>, <code>y</code>) : Tuple of 1D arrays with the parameter values and the function values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/Minuit2.jl/blob/6e6df931c8f911544c85b4362a8895cb56fd2b96/src/api.jl#LL520-L539">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../tutorials/introduction/">Introduction to Minuit2.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Monday 3 February 2025 16:43">Monday 3 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
